#!/usr/bin/python3

import json
import sys
import re
import copy
import os
import argparse
import subprocess
import numpy as np

def ensureFigDir():
  if not os.path.isdir("figures"):
    os.mkdir("figures")

def getGitRoot():
  data = subprocess.Popen(['git', 'rev-parse', '--show-toplevel'],
    stdout=subprocess.PIPE).communicate()[0].rstrip()
  return "".join(chr(x) for x in data)

ROOT = getGitRoot()

parser = argparse.ArgumentParser()
parser.add_argument('--no-plots', action='store_true', dest='no_plots')
parser.add_argument('input_file', nargs='?', metavar='RESULTS_FILE')
args = parser.parse_args()

BLUE = '\033[94m'
#GREEN = '\033[92m'
GREEN = '\033[38;2;20;139;20m'
#LIGHT_GREEN = '\033[38;2;138;226;52m'
LIGHT_GREEN = '\033[38;2;100;226;130m'
YELLOW = '\033[93m'
GRAY = '\033[38;2;151;155;147m'
RED = '\033[91m'
ENDC = '\033[0m'
BOLD = '\033[1m'
UNDERLINE = '\033[4m'

class colortext:
  def __init__(self, text, color, bold=True):
    self.text = text
    self.color = color
    self.bold = bold
  def __len__(self):
    return len(self.text)
  def __str__(self):
    return (BOLD if self.bold else "") + self.color + self.text + ENDC
def green(s):
  return colortext(s, GREEN)
def red(s):
  return colortext(s, RED)
def orange(s):
  return colortext(s, YELLOW, bold=True)
def blue(s):
  return colortext(s, BLUE)
def lightgreen(s):
  return colortext(s, LIGHT_GREEN, bold=True)
def gray(s):
  return colortext(s, GRAY, bold=False)

def json_careful_loads(s):
  try:
    return json.loads(s)
  except Exception as e:
    sys.stderr.write("[ERR] Error while parsing json: {}\n".format(e))
    sys.exit(1)

def json_careful_readlines(f):
  return [ json_careful_loads(line.rstrip('\n')) for line in f ]

def safeInsert(dict, key, value):
  if key not in dict:
    dict[key] = value
  else:
    sys.stderr.write("[WARN] Key {} is already in use; trying _{} instead.\n".format(key))
    safeInsert(dict, "_" + key, value)

def reCompile(exp):
  return re.compile(exp, re.MULTILINE)

# def parseCommaInteger(s):
#   return int(s.replace(",", ""))

# local reclaimed: 32859049984
# num local: 20999
# local gc time: 4541
# promo time: 8

def parseKiB(kibStr):
  return float(int(kibStr)) * 1024.0 / 1000.0

def parseBytesToKB(bytesStr):
  return float(int(bytesStr)) / 1000.0

def parseTimes(stdout):
  pat = reCompile(r"^time\s+(\d+.\d+).*$")
  return [float(x) for x in pat.findall(stdout)]

def parseMillisecToSec(ms):
  return float(int(ms)) / 1000.0

# sus marks: 1260000
# de checks: 0
# bytes pinned entangled: 0

# lgc count: 0
# lgc bytes reclaimed: 0
# lgc trace time(ms): 0
# lgc promo time(ms): 0
# lgc total time(ms): 0

# cgc count: 4999
# cgc bytes reclaimed: 44329304
# cgc time(ms): 841

# work time(ms): 128304
# idle time(ms): 170102

statsPatterns = \
  [ #("time", float, reCompile(r"^end-to-end\s+(\d+.\d+)s$"))
  #,
    ("space", parseKiB, reCompile(r"^\s*Maximum resident set size \(kbytes\): (\d+).*$"))
  , ("computed-average", float, reCompile(r"^average\s+(\d+.\d+).*$"))
  , ("pinned-entangled", parseBytesToKB, reCompile(r"^bytes pinned entangled: (\d+).*$"))
  , ("pinned-entangled-watermark", parseBytesToKB, reCompile(r"^bytes pinned entangled watermark: (\d+).*$"))
  , ("lgc-count", int, reCompile(r"^lgc count: (\d+)$"))
  , ("lgc-reclaimed", parseBytesToKB, reCompile(r"^lgc bytes reclaimed: (\d+)$"))
  , ("lgc-scope", parseBytesToKB, reCompile(r"^lgc bytes in scope: (\d+)$"))
  , ("lgc-time", parseMillisecToSec, reCompile(r"^lgc total time\(ms\): (\d+)$"))
  , ("cgc-count", int, reCompile(r"^cgc count: (\d+)$"))
  , ("cgc-reclaimed", parseBytesToKB, reCompile(r"^cgc bytes reclaimed: (\d+)$"))
  , ("cgc-scope", parseBytesToKB, reCompile(r"^cgc bytes in scope: (\d+)$"))
  , ("cgc-time", parseMillisecToSec, reCompile(r"^cgc time\(ms\): (\d+)$"))
  , ("work-time", parseMillisecToSec, reCompile(r"^work time\(ms\): (\d+)$"))
  , ("idle-time", parseMillisecToSec, reCompile(r"^idle time\(ms\): (\d+)$"))
  , ("num-spawns", int, reCompile(r"^num spawns\s+(\d+)$"))
  , ("num-spawns", int, reCompile(r"^num-spawns\s+(\d+)$"))
  , ("num-heartbeats", int, reCompile(r"^num heartbeats\s+(\d+)$"))
  , ("eager-spawn-pct", int, reCompile(r"^  eager\s+\d+ \((\d+)\%\)$"))
  , ("num-steals", int, reCompile(r"^num steals\s+(\d+)$"))
  # , ("promo-time", int, reCompile(r"^promo time: (\d+)$"))
  # , ("root-reclaimed", parseBytesToKB, reCompile(r"^root cc reclaimed: (\d+)$"))
  # , ("internal-reclaimed", parseBytesToKB, reCompile(r"^internal cc reclaimed: (\d+)$"))
  # , ("num-root", int, reCompile(r"^num root cc: (\d+)$"))
  # , ("num-internal", int, reCompile(r"^num internal cc: (\d+)$"))
  # , ("root-time", int, reCompile(r"^root cc time: (\d+)$"))
  # , ("internal-time", int, reCompile(r"^internal cc time: (\d+)$"))
  # , ("working-set", parseCommaInteger, reCompile(r"^max bytes live: (.*) bytes$"))
  ]

def renameConfig(c):
  return c

def renameTag(row):
  t = row['tag']
  if (t != 'tangle') and (t != 'tangle-small') and (t != 'tangle-small2') and (t != 'tangle-small3'):
    return t
  pat = re.compile(r"-p-ent\s+(.*)")
  m = pat.search(row['args1'])
  if m:
    newTag = '{}-{}'.format(t, m.group(1))
    print("found {}".format(newTag))
    return newTag
  return t

# def displayTag(t):
#   sandmarkTags = ["binarytrees5","lu-decomp","game-of-life","nbody"]
#   if t in sandmarkTags:
#     return "SM:" + t
#   if t == "delaunay-entangled":
#     return "delaunay"
#   if t == "delaunay":
#     return "delaunay-disentangled"
#   if t == "wc-entangled":
#     return "wc"
#   if t == "linefit-entangled":
#     return "linefit"
#   if t == "wc":
#     return "wc-disentangled"
#   if t == "linefit":
#     return "linefit-disentangled"
#   if t == "msort-ints":
#     return "msort-int64"
#   if t == "dedup-strings":
#     return "hash-dedup"
#   if t == "pfa-bst":
#     return "persistent-arr"
#   if t == "connectivity":
#     return "reachability"
#   if t == "low-d-decomp-boundary":
#     return "ldd-boundary"
#   if t == "bfs-find-hideg":
#     return "find-influencers"
#   return t

def displayTag(t):
  return t


foundTags = set()
foundProcs = set()

def parseStats(row):
  newRow = copy.deepcopy(row)
  for (name, convert, pat) in statsPatterns:
    m = pat.search(newRow['stdout'] + newRow['stderr'])
    if m:
      safeInsert(newRow, name, convert(m.group(1)))
  newRow['procs'] = int(newRow.get('procs', '1'))
  newRow['config'] = renameConfig(row['config'])
  newRow['tag'] = renameTag(row)

  allOutput = newRow['stdout'] + newRow['stderr']
  if 'multi' in newRow:
    for i in range(1, int(newRow['multi'])):
      allOutput += newRow['stdout{}'.format(i)] + newRow['stderr{}'.format(i)]

  tms = parseTimes(allOutput)
  try:
    newRow['avgtime'] = sum(tms) / len(tms)
  except:
    newRow['avgtime'] = None

  if newRow['avgtime'] is None:
    try:
      newRow['avgtime'] = newRow['computed-average']
    except:
      pass
  elif 'computed-average' in newRow and \
       abs(newRow['computed-average'] - newRow['avgtime']) > 0.001:
    # sanity check: might as well check that the average reported by the
    # benchmark respects the average we compute here
    sys.stderr.write("[WARN] (tag={} config={} procs={}) computed-average ({}) and avgtime ({}) differ a bit.".format(newRow['tag'], newRow['config'], newRow['procs'], newRow['computed-average'], newRow['avgtime']))

  foundTags.add(newRow['tag'])
  foundProcs.add(newRow['procs'])

  return newRow

def findTrials(data, config, tag, procs):
  result = []
  for row in data:
    if (row['config'] == config and \
        row['tag'] == tag and \
        row['procs'] == procs):
      result.append(row)
  return result

# ======================================================================

def averageTime(data, config, tag, procs, checkExpType=True):
  trials = [ r for r in findTrials(data, config, tag, procs) if (not checkExpType) or (r['exp'] == 'time') ]
  tms = [ r['avgtime'] for r in trials if 'avgtime' in r ]
  try:
    return tms[-1]
  except:
    return None

def averageSpace(data, config, tag, procs, checkExpType=True):
  trials = [ r for r in findTrials(data, config, tag, procs) if (not checkExpType) or r['exp'] == 'space' ]
  sp = [ r['space'] for r in trials if 'space' in r ]

  try:
    sp = sp[-10:] if procs > 1 else sp[-1:]
    # sp = sp[-1:]
    return sum(sp) / len(sp)
  except:
    return None

def pinnedEntangled(data, config, tag, procs):
  trials = [r for r in findTrials(data, config, tag, procs) if r['exp'] == 'space']
  ee = [ r['pinned-entangled'] for r in trials if 'pinned-entangled' in r ]
  try:
    return ee[-1] / 20.0
  except:
    return None

def averageSpaceSingle(data, config, tag, procs):
  trials = [ r for r in findTrials(data, config, tag, procs) if r['exp'] == 'single-space' ]
  sp = [ r['space'] for r in trials if 'space' in r ]

  try:
    sp = sp[-10:] if procs > 1 else sp[-1:]
    # sp = sp[-1:]
    return sum(sp) / len(sp)
  except:
    return None

def pinnedEntangledSingle(data, config, tag, procs):
  trials = [r for r in findTrials(data, config, tag, procs) if r['exp'] == 'single-space']
  ee = [ r['pinned-entangled'] for r in trials if 'pinned-entangled' in r ]
  try:
    return ee[-1]
  except:
    return None

def pinnedEntangledWatermark(data, config, tag, procs):
  trials = [r for r in findTrials(data, config, tag, procs) if r['exp'] == 'space']
  ee = [ r['pinned-entangled-watermark'] for r in trials if 'pinned-entangled-watermark' in r ]
  try:
    return ee[-1]  # note: do NOT divide by number of reps
  except:
    return None

def lgcCount(data, config, tag, procs):
  trials = [r for r in findTrials(data, config, tag, procs) if r['exp'] == 'space']
  ee = [ r['lgc-count'] for r in trials if 'lgc-count' in r ]
  try:
    return ee[-1] / 20.0
  except:
    return None

def lgcReclaimed(data, config, tag, procs):
  trials = [r for r in findTrials(data, config, tag, procs) if r['exp'] == 'space']
  ee = [ r['lgc-reclaimed'] for r in trials if 'lgc-reclaimed' in r ]
  try:
    return ee[-1] / 20.0
  except:
    return None

def lgcScope(data, config, tag, procs):
  trials = [r for r in findTrials(data, config, tag, procs) if r['exp'] == 'space']
  ee = [ r['lgc-scope'] for r in trials if 'lgc-scope' in r ]
  try:
    return ee[-1] / 20.0
  except:
    return None

def lgcTime(data, config, tag, procs):
  trials = [r for r in findTrials(data, config, tag, procs) if r['exp'] == 'space']
  ee = [ r['lgc-time'] for r in trials if 'lgc-time' in r ]
  try:
    return ee[-1] / 20.0
  except:
    return None

def cgcCount(data, config, tag, procs):
  trials = [r for r in findTrials(data, config, tag, procs) if r['exp'] == 'space']
  ee = [ r['cgc-count'] for r in trials if 'cgc-count' in r ]
  try:
    return ee[-1] / 20.0
  except:
    return None

def cgcReclaimed(data, config, tag, procs):
  trials = [r for r in findTrials(data, config, tag, procs) if r['exp'] == 'space']
  ee = [ r['cgc-reclaimed'] for r in trials if 'cgc-reclaimed' in r ]
  try:
    return ee[-1] / 20.0
  except:
    return None

def cgcScope(data, config, tag, procs):
  trials = [r for r in findTrials(data, config, tag, procs) if r['exp'] == 'space']
  ee = [ r['cgc-scope'] for r in trials if 'cgc-scope' in r ]
  try:
    return ee[-1] / 20.0
  except:
    return None

def cgcTime(data, config, tag, procs):
  trials = [r for r in findTrials(data, config, tag, procs) if r['exp'] == 'space']
  ee = [ r['cgc-time'] for r in trials if 'cgc-time' in r ]
  try:
    return ee[-1] / 20.0
  except:
    return None

def spawns(data, config, tag, procs):
  trials = [r for r in findTrials(data, config, tag, procs) if r['exp'] == 'time']
  ee = [ r['num-spawns'] for r in trials if 'num-spawns' in r ]
  try:
    return int(round(ee[-1] / 20.0))
  except:
    return None

def heartbeats(data, config, tag, procs):
  trials = [r for r in findTrials(data, config, tag, procs) if r['exp'] == 'time']
  ee = [ r['num-heartbeats'] for r in trials if 'num-heartbeats' in r ]
  try:
    return int(round(ee[-1] / 20.0))
  except:
    return None

def steals(data, config, tag, procs):
  trials = [r for r in findTrials(data, config, tag, procs) if r['exp'] == 'time']
  ee = [ r['num-steals'] for r in trials if 'num-steals' in r ]
  try:
    return int(round(ee[-1] / 20.0))
  except:
    return None

def eagerness(data, config, tag, procs):
  trials = [r for r in findTrials(data, config, tag, procs) if r['exp'] == 'time']
  ee = [ r['eager-spawn-pct'] for r in trials if 'eager-spawn-pct' in r ]
  try:
    return ee[-1]
  except:
    return None

# ======================================================================

def tm(t):
  if t is None:
    return None
  if t == 0.0:
    return int(0)
  # if t > 10.0:
  #   return int(round(t))
  try:
    if t < 1.0:
      return round(t, 3)
    if t < 10.0:
      return round(t, 2)
    elif t < 100.0:
      return round(t, 1)
    else:
      return round(t)
  except TypeError:
    print ("[ERR] Got type error trying to round {}".format(repr(t)))
    return None

def ov(x):
  if x is None:
    return None
  return "{:.2f}".format(x)

def ovv(x):
  if x is None:
    return None
  return round(x, 2)

def rat(x):
  if x is None:
    return None
  if x >= 10.0:
    return str(int(round(x)))
  if x >= 1:
    return "{:.1f}".format(x)
  else:
    return "{:.2f}".format(x)

def sd(x, y):
  try:
    return x / y
  except:
    return None

def safemul(x, y):
  try:
    return x * y
  except:
    return None

def safeadd(x, y):
  try:
    return x + y
  except:
    return None

def su(x):
  if x is None:
    return None
  return str(int(round(x)))

def bu(x):
  if x is None:
    return None
  elif x < 1.0:
    return "{:.2f}".format(x)
  return "{:.1f}".format(x)

def noLeadZero(x):
  try:
    if "0" == x[:1]:
      return x[1:]
  except:
    pass
  return x

def sp(kb):
  if kb is None:
    return None
  if kb < 0.001:
    return "0"
  num = kb
  for unit in ['K','M','G']:
    if num < 100:
      if num < 1:
        return noLeadZero("%0.2f %s" % (num, unit))
      if num < 10:
        return noLeadZero("%1.1f %s" % (num, unit))
      return "%d %s" % (round(num), unit)
      # return "%d %s" % (int(round(num,-1)), unit)
    num = num / 1000
  return noLeadZero("%1.1f %s" % (num, 'T'))

def sfmt(xx):
  if xx is None:
    return "--"
  elif type(xx) is str:
    return xx
  elif xx < 0.01:
    return noLeadZero("{:.4f}".format(xx))
  elif xx < 0.1:
    return noLeadZero("{:.3f}".format(xx))
  elif xx < 1.0:
    return noLeadZero("{:.2f}".format(xx))
  elif xx < 10.0:
    return "{:.1f}".format(xx)
  else:
    return str(int(round(xx)))

def spg(kb):
  try:
    gb = kb / (1000.0 * 1000.0)
    if gb < .01:
      return round(gb, 4)
    elif gb < .1:
      return round(gb, 3)
    elif gb < 1.0:
      return round(gb, 2)
    elif gb < 10.0:
      return round(gb, 1)
    else:
      return round(gb, 0)
  except:
    return None

def spm(kb):
  try:
    mb = kb / (1000.0)
    if mb < .01:
      return round(mb, 4)
    elif mb < .1:
      return round(mb, 3)
    elif mb < 1.0:
      return round(mb, 2)
    elif mb < 10.0:
      return round(mb, 1)
    else:
      return round(mb, 0)
  except:
    return None

def makeBold(s):
  try:
    return "{\\bf " + s + "}"
  except Exception as e:
    sys.stderr.write("[WARN] " + str(e) + "\n")
    return "--"

def pcd(b, a):
  try:
    xx = int(round(100.0 * (b-a) / abs(a)))
    return xx
  except:
    return None

def fmtpcd(xx, highlight=True):
  try:
    xx = int(round(xx))
    result = ("+" if xx >= 0.0 else "") + ("{}\\%".format(xx))
    if highlight and (xx < 0):
      return makeBold(result)
    else:
      return result
  except Exception as e:
    sys.stderr.write("[WARN] " + str(e) + "\n")
    return "--"

def ov_to_latexpcd(ov, highlight=True):
  try:
    xx = int(round(100.0 * (ov-1.0)))
    result = ("+" if xx >= 0.0 else "") + ("{}\\%".format(xx))
    if highlight and (xx < 0):
      return makeBold(result)
    else:
      return result
  except Exception as e:
    sys.stderr.write("[WARN] " + str(e) + "\n")
    return "--"

def latexpcd(b, a, highlight=True):
  try:
    xx = pcd(b, a)
    result = ("+" if xx >= 0.0 else "") + ("{}\\%".format(xx))
    if highlight and (xx < 0):
      return makeBold(result)
    else:
      return result
  except Exception as e:
    sys.stderr.write("[WARN] " + str(e) + "\n")
    return "--"

def fmt(xx):
  if xx is None:
    return "--"
  elif type(xx) is str:
    return xx
  elif xx < 1.0:
    return noLeadZero("{:.3f}".format(xx))
  elif xx < 10.0:
    return "{:.2f}".format(xx)
  elif xx < 100.0:
    return "{:.1f}".format(xx)
  else:
    return str(int(round(xx)))

def geomean(iterable):
  try:
    a = np.array(iterable)
    return a.prod()**(1.0/len(a))
  except:
    return None

def average(iterable):
  try:
    a = np.array(iterable)
    return a.sum() * (1.0/len(a))
  except:
    return None

# =========================================================================

delimWidth = 2

def makeline(row, widths, align):
  bits = []
  i = 0
  while i < len(row):
    j = i+1
    while j < len(row) and (row[j] is None):
      j += 1
    availableWidth = int(sum(widths[i:j]) + delimWidth*(j-i-1))
    s = str(row[i])
    w = " " * (availableWidth - len(row[i]))
    aa = align(i)
    if aa == "l":
      ln = s + w
    elif aa == "r":
      ln = w + s
    elif aa == "c":
      ln = w[:len(w)/2] + s + w[len(w)/2:]
    else:
      raise ValueError("invalid formatter: {}".format(aa))
    bits.append(ln)
    i = j
  return (" " * delimWidth).join(bits)

def table(rows, align=None):
  numCols = max(len(row) for row in rows if not isinstance(row, str))

  widths = [0] * numCols
  for row in rows:
    # string rows are used for formatting
    if isinstance(row, str):
      continue

    i = 0
    while i < len(row):
      j = i+1
      while j < len(row) and (row[j] is None):
        j += 1
      # rw = len(stripANSI(str(row[i])))
      # rw = len(str(row[i]))
      rw = len(row[i])
      for k in range(i, j):
        w = (rw / (j-i)) + (1 if k < rw % (j-i) else 0)
        widths[k] = max(widths[k], w)
      i = j

  totalWidth = int(sum(widths) + delimWidth*(numCols-1))

  def aa(i):
    try:
      return align(i)
    except:
      return "l"

  output = []
  for row in rows:
    if row == "-" or row == "=":
      output.append(row * totalWidth)
      continue
    elif isinstance(row, str):
      raise ValueError("bad row: {}".format(row))
    output.append(makeline(row, widths, aa))

  return "\n".join(output)

# =========================================================================

def mostRecentResultsFile(suffix=""):
  try:
    files = os.listdir(os.path.join(str(ROOT), "results"))
  except Exception as e:
    print(e)
    raise e

  pattern = r'\d{6}-\d{6}'
  if suffix != "":
    pattern = pattern + "-" + suffix + "$"
  else:
    pattern = pattern + "$"
  # A bit of a hack. Filenames are ...YYMMDD-hhmmss, so lexicographic string
  # comparison is correct for finding the most recent (i.e. maximum) file
  mostRecent = max(p for p in files if re.match(pattern, p))
  return mostRecent

if args.input_file:
  timingsFile = args.input_file
else:
  print("[INFO] no results file argument; finding most recent")
  try:
    mostRecent = mostRecentResultsFile()
  except Exception as e:
    print(e)
    print("[ERR] could not find most recent results file\n " + \
          "  check that these are formatted as 'YYMMSS-hhmmss'")
    sys.exit(1)
  timingsFile = os.path.join(ROOT, 'results', mostRecent)

print("[INFO] reading {}\n".format(timingsFile))
with open(timingsFile, 'r') as data:
  resultsData = json_careful_readlines(data)
D = [ parseStats(row) for row in resultsData ]
P = sorted(list(foundProcs))
maxp = max(p for p in foundProcs if p <= 112)
orderedTags = sorted(list(foundTags), key=displayTag)

foundProcs = set()
foundTags = set()

def keepTag(t):
  return True

mplOnlyTags = [ t for t in orderedTags if keepTag(t) ]

def isNGTag(tag):
  return "-ng" in tag

def isNormalTag(tag):
  return not isNGTag(tag) and tag != "fork-stress"

def isOtherTag(tag):
  return tag == "fork-stress"

ngTags = [t for t in orderedTags if isNGTag(t)]
normalTags = [t for t in orderedTags if isNormalTag(t)]
otherTags = [t for t in orderedTags if isOtherTag(t)]

# orderedTags = [ t for t in orderedTags if t not in sandmarkTags ]

# ===========================================================================

def filterSome(xs):
  return [x for x in xs if x is not None]

# def seqOverhead(tag):
#   return sd(averageTime(D, 'mpl-em', tag, 1),averageTime(D, 'mpl', tag, 1))
# def parOverhead(tag):
#   return sd(averageTime(D, 'mpl-em', tag, maxp),averageTime(D, 'mpl', tag, maxp))
# def seqSpaceOverhead(tag):
#   return sd(averageSpace(D, 'mpl-em', tag, 1),averageSpace(D, 'mpl', tag, 1))
# def parSpaceOverhead(tag):
#   return sd(averageSpace(D, 'mpl-em', tag, maxp),averageSpace(D, 'mpl', tag, maxp))

# print "geomean 1-core time overhead", geomean(filterSome([seqOverhead(t) for t in disentangledTags]))
# print "geomean {}-core time overhead".format(maxp), geomean(filterSome([parOverhead(t) for t in disentangledTags]))
# print "geomean 1-core space overhead", geomean(filterSome([seqSpaceOverhead(t) for t in disentangledTags]))
# print "geomean {}-core space overhead".format(maxp), geomean(filterSome([parSpaceOverhead(t) for t in disentangledTags]))

# ===========================================================================

# percent difference (b-a)/|a|
def color_pcd(b, a):
  try:
    xx = 100.0 * (b-a) / abs(a)
    result = ("+" if xx >= 0.0 else "") + ("{:.1f}%".format(xx))
    if xx >= 10.0:
      return red(result)
    elif xx >= 5.0:
      return orange(result)
    elif xx <= -10.0:
      return green(result)
    elif xx <= -5.0:
      return lightgreen(result)
    else:
      return gray(result)
  except:
    return None

# def sp(kb):
#   if kb is None:
#     return None
#   num = kb
#   for unit in ['K','M','G']:
#     if num < 1000:
#       return "%3.1f %s" % (num, unit)
#     num = num / 1000
#   return "%3.1f %s" % (num, 'T')

def defaultAlign(i):
  return "r" if i == 0 else "l"


# ============================================================================
# ============================================================================

def safestr(x):
  if x is None:
    return "--"
  return str(x)

# ============================================================================
# ============================================================================

def doOverheadsAndSpeedups():
  headers = ['', 'Baseline', '|', 'T(1)', None, '|', 'Overhead', None, '|', 'T({})'.format(maxp), None, '|', 'Speedup', None]
  headers1 = ['Benchmark', 'MLton', '|', 'MPL', 'HB', '|', 'MPL', 'HB', '|', 'MPL', 'HB', '|', 'MPL', 'HB']
  tt = [headers, "-", headers1, "="]

  def doTag(tag):
    ts = tm(averageTime(D, 'mlton', tag, 1))
    mt1 = tm(averageTime(D, 'mpl', tag, 1))
    ht1 = tm(averageTime(D, 'local-hb', tag, 1))
    mtp = tm(averageTime(D, 'mpl', tag, maxp))
    htp = tm(averageTime(D, 'local-hb', tag, maxp))

    winner1 = (ht1 < mt1)
    winnerp = (htp < mtp)

    def cc(b, x):
      return (green(x) if b else x)
    def ccm1(x):
      return cc(mt1 <= ht1, x)
    def ccmp(x):
      return cc(mtp <= htp, x)
    def cch1(x):
      return cc(ht1 <= mt1, x)
    def cchp(x):
      return cc(htp <= mtp, x)

    row = [
      safestr(ts),
      '|',
      ccm1(safestr(mt1)),
      cch1(safestr(ht1)),
      '|',
      ccm1(ov(sd(mt1, ts))),
      cch1(ov(sd(ht1, ts))),
      '|',
      ccmp(safestr(mtp)),
      cchp(safestr(htp)),
      '|',
      ccmp(su(sd(ts, mtp))),
      cchp(su(sd(ts, htp)))
    ]
    row = [displayTag(tag)] + [x if x is not None else "--" for x in row]
    tt.append(row)

  for tag in ngTags:
    doTag(tag)

  tt.append("-")

  mpl_overheads = \
    filterSome(
      ovv(sd(tm(averageTime(D, 'mpl', tag, 1)), tm(averageTime(D, 'mlton', tag, 1))))
      for tag in ngTags)
  hb_overheads = \
    filterSome(
      ovv(sd(tm(averageTime(D, 'local-hb', tag, 1)), tm(averageTime(D, 'mlton', tag, 1))))
      for tag in ngTags)

  mpl_speedups = \
    filterSome(
      ovv(sd(tm(averageTime(D, 'mlton', tag, 1)), tm(averageTime(D, 'mpl', tag, maxp))))
      for tag in ngTags)
  hb_speedups = \
    filterSome(
      ovv(sd(tm(averageTime(D, 'mlton', tag, 1)), tm(averageTime(D, 'local-hb', tag, maxp))))
      for tag in ngTags)

  tt.append(["min", "", "", "", "", "", ov(min(mpl_overheads)), ov(min(hb_overheads)), "", "", "", "", su(min(mpl_speedups)), su(min(hb_speedups))])
  tt.append(["geomean", "", "", "", "", "", ov(geomean(mpl_overheads)), ov(geomean(hb_overheads)), "", "", "", "", su(geomean(mpl_speedups)), su(geomean(hb_speedups))])
  tt.append(["max", "", "", "", "", "", ov(max(mpl_overheads)), ov(max(hb_overheads)), "", "", "", "", su(max(mpl_speedups)), su(max(hb_speedups))])

  print("OVERHEADS AND SPEEDUPS")
  print(table(tt, defaultAlign))
  print("")


doOverheadsAndSpeedups()

# ============================================================================
# ============================================================================

def doClosenessToManualGrain():
  headers = ['', 'T(1)', None, None, '|', 'T({})'.format(maxp), None, None]
  headers1 = ['Benchmark', 'Man', 'NG', 'Overhead', '|', 'Man', 'NG', 'Overhead']
  tt = [headers, "-", headers1, "="]

  def doCmp(tag, ngtag):
    t1 = tm(averageTime(D, 'local-hb', tag, 1))
    ngt1 = tm(averageTime(D, 'local-hb', ngtag, 1))
    tp = tm(averageTime(D, 'local-hb', tag, maxp))
    ngtp = tm(averageTime(D, 'local-hb', ngtag, maxp))

    row = [
      safestr(t1),
      safestr(ngt1),
      ov(sd(ngt1, t1)),
      '|',
      safestr(tp),
      safestr(ngtp),
      ov(sd(ngtp, tp))
    ]
    row = [displayTag(tag)] + [x if x is not None else "--" for x in row]
    tt.append(row)

  for tag in normalTags:
    doCmp(tag, tag + '-ng')

  print("MANUAL VS NO-GRAIN PERFORMANCE")
  print(table(tt, defaultAlign))
  print("")

doClosenessToManualGrain()

# ============================================================================
# ============================================================================

# expects grain one of
# ['large-grain', 'small-grain', 'cilk-large-grain', 'cilk-small-grain']
def doHeartbeatTimeCmp():
  headers = ['', 'Baseline', '|', 'T(1)', None, None, None, '|', 'T({})'.format(maxp), None, None, None, '|', 'Speedups', None, None]
  headers1 = ['Benchmark', 'MLton', '|', 'MPL', 'E', 'HB', 'HB/E', '|', 'MPL', 'E', 'HB', 'HB/E', '|', 'MPL', 'E', 'HB']
  tt = [headers, "-", headers1, "="]

  def doTag(tag):
    ts = tm(averageTime(D, 'mlton', tag, 1))
    mt1 = tm(averageTime(D, 'mpl', tag, 1))
    et1 = tm(averageTime(D, 'local-hb-sim-eager', tag, 1))
    ht1 = tm(averageTime(D, 'local-hb', tag, 1))
    mtp = tm(averageTime(D, 'mpl', tag, maxp))
    etp = tm(averageTime(D, 'local-hb-sim-eager', tag, maxp))
    htp = tm(averageTime(D, 'local-hb', tag, maxp))

    row = [
      safestr(ts),
      '|',
      safestr(mt1),
      safestr(et1),
      safestr(ht1),
      color_pcd(ht1, et1),
      '|',
      safestr(mtp),
      safestr(etp),
      safestr(htp),
      color_pcd(htp, etp),
      '|',
      su(sd(ts, mtp)),
      su(sd(ts, etp)),
      su(sd(ts, htp))
    ]
    row = [displayTag(tag)] + [x if x is not None else "--" for x in row]
    tt.append(row)

  for tag in otherTags:
    doTag(tag)

  tt.append("-")

  for tag in normalTags:
    doTag(tag)
  
  tt.append("-")

  for tag in ngTags:
    doTag(tag)

  print("HEARTBEAT TIME COMPARISON")
  print(table(tt, defaultAlign))
  print("")


# doHeartbeatTimeCmp()

# ============================================================================

def doHeartbeatStats():
  headers = ['', 'Heartbeats', 'Pars', 'Spawns', 'Eagerness', 'Steals', 'Spawns/Steal', 'Pars/Steal']
  tt = [headers, "="]

  def doTag(tag):
    numSpawns = spawns(D, 'local-hb', tag, maxp)
    numHeartbeats = heartbeats(D, 'local-hb', tag, maxp)
    pctEagerness = eagerness(D, 'local-hb', tag, maxp)
    numSteals = steals(D, 'local-hb', tag, maxp)

    numPars = spawns(D, 'local-hb-sim-eager', tag, maxp)

    row = [
      safestr(numHeartbeats),
      safestr(numPars),
      safestr(numSpawns),
      safestr(pctEagerness) + "%",
      safestr(numSteals),
      safestr(sd(numSpawns, numSteals)),
      safestr(sd(numPars, numSteals))
    ]
    row = [displayTag(tag)] + [x if x is not None else "--" for x in row]
    tt.append(row)

  for tag in otherTags:
    doTag(tag)

  tt.append("-")

  for tag in normalTags:
    doTag(tag)
  
  tt.append("-")

  for tag in ngTags:
    doTag(tag)

  print("HEARTBEAT STATS")
  print(table(tt, defaultAlign))
  print("")

# doHeartbeatStats()

# ============================================================================

def doHeartbeatSpaceCmp():
  headers = ['', 'R(1)', None, None, None, None, '|', 'R({})'.format(maxp), None, None, None, None]
  headers1 = ['Benchmark', 'MPL', 'GWA', 'GWA/M', 'GWAN', 'GWAN/M', '|', 'MPL', 'GWA', 'GWA/M', 'GWAN', 'GWAN/M']
  tt = [headers, "-", headers1, "="]

  def doTag(tag):
    # rs = spg(averageSpace(D, 'mlton', tag, 1))
    mr1 = spg(averageSpace(D, 'mpl', tag, 1))
    gwar1 = spg(averageSpace(D, 'local-hb-gwa-new', tag, 1))
    gwanr1 = spg(averageSpace(D, 'local-hb-gwa-newest', tag, 1))
    mrp = spg(averageSpace(D, 'mpl', tag, maxp))
    gwarp = spg(averageSpace(D, 'local-hb-gwa-new', tag, maxp))
    gwanrp = spg(averageSpace(D, 'local-hb-gwa-newest', tag, maxp))

    row = [
      # rs,
      str(mr1),
      str(gwar1),
      color_pcd(gwar1, mr1),
      str(gwanr1),
      color_pcd(gwanr1, mr1),
      '|',
      str(mrp),
      str(gwarp),
      color_pcd(gwarp, mrp),
      str(gwanrp),
      color_pcd(gwanrp, mrp)
    ]
    row = [displayTag(tag)] + [x if x is not None else "--" for x in row]
    tt.append(row)

  for tag in otherTags:
    doTag(tag)

  tt.append("-")

  for tag in normalTags:
    doTag(tag)
  
  tt.append("-")

  for tag in ngTags:
    doTag(tag)

  print("HEARTBEAT SPACE COMPARISON")
  print(table(tt, defaultAlign))
  print("")

# ============================================================================

def doHeartbeatPolicyNums():
  headers = ['', 'T(1)', None, None, None, None, '|', 'T({})'.format(maxp), None, None, None, None, '|', 'R(1)', None, None, None, None, '|', 'R({})'.format(maxp), None, None, None, None]
  headers1 = ['Benchmark', 'NPC', 'EH1', 'EH2', 'GWA', 'GWAN', '|', 'NPC', 'EH1', 'EH2', 'GWA', 'GWAN', '|', 'NPC', 'EH1', 'EH2', 'GWA', 'GWAN', '|', 'NPC', 'EH1', 'EH2', 'GWA', 'GWAN']
  tt = [headers, "-", headers1, "="]

  def doTag(tag):
    npct1 = tm(averageTime(D, 'local-hb-npc', tag, 1))
    npcr1 = spg(averageSpace(D, 'local-hb-npc', tag, 1))
    npctp = tm(averageTime(D, 'local-hb-npc', tag, maxp))
    npcrp = spg(averageSpace(D, 'local-hb-npc', tag, maxp))

    eh1t1 = tm(averageTime(D, 'local-hb-eh1', tag, 1))
    eh1r1 = spg(averageSpace(D, 'local-hb-eh1', tag, 1))
    eh1tp = tm(averageTime(D, 'local-hb-eh1', tag, maxp))
    eh1rp = spg(averageSpace(D, 'local-hb-eh1', tag, maxp))

    eh2t1 = tm(averageTime(D, 'local-hb-eh2', tag, 1))
    eh2r1 = spg(averageSpace(D, 'local-hb-eh2', tag, 1))
    eh2tp = tm(averageTime(D, 'local-hb-eh2', tag, maxp))
    eh2rp = spg(averageSpace(D, 'local-hb-eh2', tag, maxp))

    gwat1 = tm(averageTime(D, 'local-hb-gwa-new', tag, 1))
    gwar1 = spg(averageSpace(D, 'local-hb-gwa-new', tag, 1))
    gwatp = tm(averageTime(D, 'local-hb-gwa-new', tag, maxp))
    gwarp = spg(averageSpace(D, 'local-hb-gwa-new', tag, maxp))

    gwant1 = tm(averageTime(D, 'local-hb-gwa-newest', tag, 1))
    gwanr1 = spg(averageSpace(D, 'local-hb-gwa-newest', tag, 1))
    gwantp = tm(averageTime(D, 'local-hb-gwa-newest', tag, maxp))
    gwanrp = spg(averageSpace(D, 'local-hb-gwa-newest', tag, maxp))

    row = [
      str(npct1),
      str(eh1t1),
      str(eh2t1),
      str(gwat1),
      str(gwant1),
      '|',
      str(npctp),
      str(eh1tp),
      str(eh2tp),
      str(gwatp),
      str(gwantp),
      '|',
      str(npcr1),
      str(eh1r1),
      str(eh2r1),
      str(gwar1),
      str(gwanr1),
      '|',
      str(npcrp),
      str(eh1rp),
      str(eh2rp),
      str(gwarp),
      str(gwanrp)
    ]
    row = [displayTag(tag)] + [x if x is not None else "--" for x in row]
    tt.append(row)

  for tag in otherTags:
    doTag(tag)

  tt.append("-")

  for tag in normalTags:
    doTag(tag)
  
  tt.append("-")

  for tag in ngTags:
    doTag(tag)

  print("HEARTBEAT POLICIES: RAW NUMBERS")
  print("| NPC (naive pcall):       use pcall for all forks")
  print("| EH1 (eager-heuristic-1): eager fork below lowP depth via MPL-style closure-on-deque")
  print("| EH2 (eager-heuristic-2): eager fork below lowP depth by sending self heartbeat immediately after pcall")
  print("| GWA (greedy-work-amort): collect spare heartbeat tokens and spend eagerly at fork (by sending self heartbeat)")
  print(table(tt, defaultAlign))
  print("")

def doHeartbeatPolicyCmp():
  headers = ['', 'T(1)', None, None, None, None, '|', 'T({})'.format(maxp), None, None, None, None, '|', 'R(1)', None, None, None, None, '|', 'R({})'.format(maxp), None, None, None, None]
  headers1 = ['Benchmark', 'NPC', 'EH1', 'EH2', 'GWA', 'GWAN', '|', 'NPC', 'EH1', 'EH2', 'GWA', 'GWAN', '|', 'NPC', 'EH1', 'EH2', 'GWA', 'GWAN', '|', 'NPC', 'EH1', 'EH2', 'GWA', 'GWAN']
  tt = [headers, "-", headers1, "="]

  def doTag(tag):
    npct1 = tm(averageTime(D, 'local-hb-npc', tag, 1))
    npcr1 = spg(averageSpace(D, 'local-hb-npc', tag, 1))
    npctp = tm(averageTime(D, 'local-hb-npc', tag, maxp))
    npcrp = spg(averageSpace(D, 'local-hb-npc', tag, maxp))

    eh1t1 = tm(averageTime(D, 'local-hb-eh1', tag, 1))
    eh1r1 = spg(averageSpace(D, 'local-hb-eh1', tag, 1))
    eh1tp = tm(averageTime(D, 'local-hb-eh1', tag, maxp))
    eh1rp = spg(averageSpace(D, 'local-hb-eh1', tag, maxp))

    eh2t1 = tm(averageTime(D, 'local-hb-eh2', tag, 1))
    eh2r1 = spg(averageSpace(D, 'local-hb-eh2', tag, 1))
    eh2tp = tm(averageTime(D, 'local-hb-eh2', tag, maxp))
    eh2rp = spg(averageSpace(D, 'local-hb-eh2', tag, maxp))

    gwat1 = tm(averageTime(D, 'local-hb-gwa-new', tag, 1))
    gwar1 = spg(averageSpace(D, 'local-hb-gwa-new', tag, 1))
    gwatp = tm(averageTime(D, 'local-hb-gwa-new', tag, maxp))
    gwarp = spg(averageSpace(D, 'local-hb-gwa-new', tag, maxp))

    gwant1 = tm(averageTime(D, 'local-hb-gwa-newest', tag, 1))
    gwanr1 = spg(averageSpace(D, 'local-hb-gwa-newest', tag, 1))
    gwantp = tm(averageTime(D, 'local-hb-gwa-newest', tag, maxp))
    gwanrp = spg(averageSpace(D, 'local-hb-gwa-newest', tag, maxp))

    row = [
      str(npct1),
      color_pcd(eh1t1, npct1),
      color_pcd(eh2t1, npct1),
      color_pcd(gwat1, npct1),
      color_pcd(gwant1, npct1),
      '|',
      str(npctp),
      color_pcd(eh1tp, npctp),
      color_pcd(eh2tp, npctp),
      color_pcd(gwatp, npctp),
      color_pcd(gwantp, npctp),
      '|',
      str(npcr1),
      color_pcd(eh1r1, npcr1),
      color_pcd(eh2r1, npcr1),
      color_pcd(gwar1, npcr1),
      color_pcd(gwanr1, npcr1),
      '|',
      str(npcrp),
      color_pcd(eh1rp, npcrp),
      color_pcd(eh2rp, npcrp),
      color_pcd(gwarp, npcrp),
      color_pcd(gwanrp, npcrp)
    ]
    row = [displayTag(tag)] + [x if x is not None else "--" for x in row]
    tt.append(row)

  for tag in otherTags:
    doTag(tag)

  tt.append("-")

  for tag in normalTags:
    doTag(tag)
  
  tt.append("-")

  for tag in ngTags:
    doTag(tag)

  print("HEARTBEAT POLICY COMPARISON")
  print("| NPC (naive pcall):       use pcall for all forks")
  print("| EH1 (eager-heuristic-1): eager fork below lowP depth via MPL-style closure-on-deque")
  print("| EH2 (eager-heuristic-2): eager fork below lowP depth by sending self heartbeat immediately after pcall")
  print("| GWA (greedy-work-amort): collect spare heartbeat tokens and spend eagerly at fork (by sending self heartbeat)")
  print(table(tt, defaultAlign))
  print("")

# ============================================================================

# doHeartbeatTimeCmp()
# doHeartbeatSpaceCmp()
# doHeartbeatPolicyCmp()
# doHeartbeatPolicyNums()

# ============================================================================

import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1.inset_locator import zoomed_inset_axes 
from mpl_toolkits.axes_grid1.inset_locator import mark_inset
from matplotlib.ticker import MultipleLocator

def getspeedup(config, tag, p):
  try:
    baseline = averageTime(D, 'mlton', tag, 1)
    return baseline / averageTime(D, config, tag, p)
  except Exception as e:
    sys.stderr.write('[WARN] error while plotting speedup for {} at P={}: {}\n'.format(tag, p, e))
    return None

def speedupPlot(outputName, config, tagsSortedBySpeedups, tagsSortedByName, offset):
  plt.figure(figsize=(7,7))
  # markers = ['o','v','^','<','>','s','*','d','D','+','x','|','','','','','']
  colors = ['blue', 'darkturquoise', 'darkgreen', 'darkviolet', 'red', 'goldenrod','dimgrey', 'brown']
  # 'black',
  markers = ['o','v','^','<','>','s','d']
  # ,'D','*','P','X'
  linestyles = ['solid', 'dashed','dashdot']

  # markers = ['.'] * len(speedupTags)
  procs = P

  fontSize = 18
  legendFontSize = 16
  markerSize = 14

  usedFull = dict()
  usedNoc = dict()

  plt.plot([0,maxp+1], [0,maxp+1], marker="", color="grey", linewidth=0.8)
  lines = []
  for tag in tagsSortedByName:
    try:
      baseline = averageTime(D, 'mlton', tag, 1)
      speedups = list(map((lambda p: getspeedup(config, tag, p)), procs))

      i = offset + tagsSortedBySpeedups.index(tag)
      ci = i % len(colors)
      mi = i % len(markers)
      si = i % len(linestyles)

      if tuple((ci, mi, si)) in usedFull:
        otherTag = usedFull[tuple((ci, mi, si))]
        sys.stderr.write('[WARN] uh oh: {} and {} have same style\n'.format(tag, otherTag))
      else:
        usedFull[tuple((ci, mi, si))] = tag

      if tuple((mi, si)) in usedNoc:
        otherTag = usedNoc[tuple((mi, si))]
        if tuple((ci, mi, si)) not in usedFull:
          sys.stderr.write('[WARN] uh oh: {} and {} only differ by color\n'.format(tag, otherTag))
      else:
        usedNoc[tuple((mi, si))] = tag

      color = colors[ci]
      marker = markers[mi]
      linestyle = linestyles[si]
      # print("tag {} is index {}: {} {} {}".format(tag, i, color, marker, linestyle))
      lines.append(plt.plot(procs, speedups, linestyle=linestyle, marker=marker, markersize=markerSize, mec='black', mew=0.0, linewidth=1.3, color=color, alpha=0.8))
    except Exception as e:
      sys.stderr.write('[WARN] error while plotting speedup for {}: {}\n'.format(tag, e))

  # this sets the legend.
  font = {
    'size': legendFontSize,
    #'family' : 'normal',
    #'weight' : 'bold',
  }
  matplotlib.rc('font', **font)

  # make sure to use truetype fonts
  matplotlib.rcParams['pdf.fonttype'] = 42
  matplotlib.rcParams['ps.fonttype'] = 42

  # set legend position
  matplotlib.rcParams['legend.loc'] = 'upper left'

  ticks = [1] + list(range(10, maxp+1, 10))

  plt.xlabel('Processors', fontsize=fontSize)
  plt.ylabel('Speedup', fontsize=fontSize)
  plt.yticks(ticks, fontsize=fontSize)
  plt.xticks(ticks, fontsize=fontSize)
  plt.xlim(0, maxp+1)
  plt.ylim(0, maxp+1)
  plt.gca().grid(axis='both', linestyle='dotted')
  plt.gca().set_axisbelow(True)
  # plt.margins(y=10)

  if True:
    plt.legend(
      [b[0] for b in lines],
      map(displayTag, tagsSortedByName),
      # bbox_to_anchor=(-0.16,1.05),
      # loc='upper right',
      bbox_to_anchor=(-0.16,1.01),
      loc='upper right',
      ncol=1
    )

  ensureFigDir()
  # outputName = 'figures/mpl-speedups.pdf'
  plt.savefig(outputName, bbox_inches='tight')
  sys.stdout.write("[INFO] output written to {}\n".format(outputName))
  plt.close()



speedupTags = sorted([
  tag for tag in mplOnlyTags
  if (averageTime(D, 'local-hb-eh1', tag, maxp) is not None)
  and tag not in sandmarkTags
], key=displayTag)



def doSpeedups(outputName, config, tags):
  def sortkey(tag):
    return tag
    # try:
    #   return 1.0/getspeedup(config, tag, maxp)
    # except:
    #   return 1.0/55.0

  speedupPlot(
    "figures/{}.pdf".format(outputName),
    config,
    sorted(tags, key=sortkey),
    tags,
    0)

# doSpeedups('mpl-speedups-ng', 'mpl', ngTags)
# doSpeedups('mpl-speedups-normal', 'mpl', normalTags)
# doSpeedups('local-hb-gwa-speedups-ng', 'local-hb-gwa', ngTags)
# doSpeedups('local-hb-gwa-speedups-normal', 'local-hb-gwa', normalTags)

# ============================================================================
# ============================================================================
# ============================================================================
print("[INFO] done reporting {}".format(timingsFile))